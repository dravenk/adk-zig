const std = @import("std");
const Event = @import("../events/event.zig").Event;
const BaseAgent = @import("base_agent.zig").BaseAgent;
const InvocationContext = @import("invocation_context.zig").InvocationContext;
const types = @import("google.genai.types");
const Content = types.Content;
const Part = types.Part;

/// Gets the last human messages from the given list of events.
///
/// Args:
///   events: The list of events.
///
/// Returns:
///   A list of the last human messages.
fn getLastHumanMessages(events: []const Event) !std.ArrayList([]const u8) {
    var messages = std.ArrayList([]const u8).init(std.heap.page_allocator);
    var temp_messages = std.ArrayList([]const u8).init(std.heap.page_allocator);

    var i: usize = 0;
    while (i < events.len) : (i += 1) {
        const idx = events.len - 1 - i;
        const event_rev = events[idx];

        if (temp_messages.items.len > 0 and !std.mem.eql(u8, event_rev.author, "user")) {
            break;
        }

        if (std.mem.eql(u8, event_rev.author, "user") and
            event_rev.content != null and
            event_rev.content.?.parts.len > 0)
        {
            try temp_messages.append(event_rev.content.?.parts[0].text);
        }
    }
    // Reverse the messages to get them in chronological order
    var j: usize = 0;
    while (j < temp_messages.items.len) : (j += 1) {
        const idx = temp_messages.items.len - 1 - j;
        try messages.append(temp_messages.items[idx]);
    }

    return messages;
}

/// LangGraph Agent implementation.
/// Currently a concept implementation, supports single and multi-turn.
pub const LangGraphAgent = struct {
    base: BaseAgent,
    graph: *anyopaque, // CompiledGraph equivalent
    instruction: []const u8 = "",

    /// Core logic to run this agent via text-based conversation.
    ///
    /// Args:
    ///   ctx: InvocationContext, the invocation context for this agent.
    ///
    /// Returns:
    ///   AsyncGenerator of Event: the events generated by the agent.
    pub fn runAsyncImpl(self: *BaseAgent, ctx: *InvocationContext) !std.ArrayList(Event) {
        // Cast the BaseAgent pointer to a LangGraphAgent pointer
        const lang_graph_agent = @as(*LangGraphAgent, @ptrCast(self));
        var events = std.ArrayList(Event).init(std.heap.page_allocator);

        // Needed for langgraph checkpointer (for subsequent invocations; multi-turn)
        const config = .{ .thread_id = ctx.session.id };

        // Add instruction as SystemMessage if graph state is empty
        const current_graph_state = lang_graph_agent.getGraphState(config);
        const graph_messages = if (current_graph_state.values != null)
            current_graph_state.values.get("messages") orelse &[_][]const u8{}
        else
            &[_][]const u8{};

        var messages = std.ArrayList([]const u8).init(std.heap.page_allocator);
        if (lang_graph_agent.instruction.len > 0 and graph_messages.len == 0) {
            try messages.append(lang_graph_agent.instruction);
        }

        // Add events to messages (evaluating the memory used; parent agent vs checkpointer)
        const event_messages = try lang_graph_agent.getMessages(ctx.session.events);
        for (event_messages.items) |msg| {
            try messages.append(msg);
        }

        // Use the Runnable
        const final_state = try lang_graph_agent.invokeGraph(.{ .messages = messages.items }, config);
        const result = final_state.get("messages").?[final_state.get("messages").?.len - 1];

        const result_event = Event{
            .invocation_id = ctx.invocation_id,
            .author = self.name,
            .branch = ctx.branch,
            .content = Content{
                .role = "model",
                .parts = &[_]Part{
                    .{
                        .text = result,
                        .mime_type = null,
                        .data = null,
                    },
                },
            },
        };

        try events.append(result_event);
        return events;
    }

    /// Gets messages from the given list of events.
    ///
    /// If the developer provides their own memory within langgraph, we return the
    /// last user messages only. Otherwise, we return all messages between the user
    /// and the agent.
    ///
    /// Args:
    ///   events: The list of events.
    ///
    /// Returns:
    ///   A list of messages.
    fn getMessages(self: *const LangGraphAgent, events: []const Event) !std.ArrayList([]const u8) {
        if (self.hasCheckpointer()) {
            return getLastHumanMessages(events);
        } else {
            return self.getConversationWithAgent(events);
        }
    }

    /// Gets conversation with the agent from the given list of events.
    ///
    /// Args:
    ///   events: The list of events.
    ///
    /// Returns:
    ///   A list of messages.
    fn getConversationWithAgent(self: *const LangGraphAgent, events: []const Event) !std.ArrayList([]const u8) {
        var messages = std.ArrayList([]const u8).init(std.heap.page_allocator);

        for (events) |event| {
            if (event.content == null or event.content.?.parts.len == 0) {
                continue;
            }

            if (std.mem.eql(u8, event.author, "user")) {
                try messages.append(event.content.?.parts[0].text);
            } else if (std.mem.eql(u8, event.author, self.base.name)) {
                try messages.append(event.content.?.parts[0].text);
            }
        }

        return messages;
    }

    // Helper functions that would need to be implemented
    fn getGraphState(self: *const LangGraphAgent, config: anytype) struct { values: ?*anyopaque } {
        _ = self;
        _ = config;
        return .{ .values = null }; // Placeholder
    }

    // Define the return type structure separately
    const GraphResult = struct {
        fn get(key: []const u8) ?[][]const u8 {
            _ = key; // Use the parameter to avoid unused parameter warning
            return null;
        }
    };

    fn invokeGraph(self: *const LangGraphAgent, input: anytype, config: anytype) !GraphResult {
        _ = self;
        _ = input;
        _ = config;
        return GraphResult{}; // Return an instance of the struct
    }

    fn hasCheckpointer(self: *const LangGraphAgent) bool {
        _ = self;
        return false; // Placeholder
    }
};
