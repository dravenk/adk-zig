const std = @import("std");
const Event = @import("../events/event.zig").Event;
const CallbackContext = @import("callback_context.zig").CallbackContext;
const InvocationContext = @import("invocation_context.zig").InvocationContext;
const Content = @import("google.genai.types").Content;

/// Callback signature that is invoked before the agent run.
///
/// Args:
///   callback_context: Context for the callback.
///
/// Returns:
///   The content to return to the user. When set, the agent run will skipped and
///   the provided content will be returned to user.
pub const BeforeAgentCallback = fn (callback_context: *CallbackContext) ?Content;

/// Callback signature that is invoked after the agent run.
///
/// Args:
///   callback_context: Context for the callback.
///
/// Returns:
///   The content to return to the user. When set, the agent run will skipped and
///   the provided content will be appended to event history as agent response.
pub const AfterAgentCallback = fn (callback_context: *CallbackContext) ?Content;

/// Base class for all agents in Agent Development Kit.
pub const BaseAgent = struct {
    name: []const u8,
    /// The agent's name.
    ///
    /// Agent name must be a valid identifier and unique within the agent tree.
    /// Agent name cannot be "user", since it's reserved for end-user's input.
    description: []const u8 = "",
    /// Description about the agent's capability.
    ///
    /// The model uses this to determine whether to delegate control to the agent.
    /// One-line description is enough and preferred.
    parent_agent: ?*BaseAgent = null,
    /// The parent agent of this agent.
    ///
    /// Note that an agent can ONLY be added as sub-agent once.
    ///
    /// If you want to add one agent twice as sub-agent, consider to create two agent
    /// instances with identical config, but with different name and add them to the
    /// agent tree.
    sub_agents: std.ArrayList(*BaseAgent),
    /// The sub-agents of this agent.
    before_agent_callback: ?BeforeAgentCallback = null,
    /// Callback signature that is invoked before the agent run.
    ///
    /// Args:
    ///   callback_context: Context for the callback.
    ///
    /// Returns:
    ///   The content to return to the user. When set, the agent run will skipped and
    ///   the provided content will be returned to user.
    after_agent_callback: ?AfterAgentCallback = null,
    /// Callback signature that is invoked after the agent run.
    ///
    /// Args:
    ///   callback_context: Context for the callback.
    ///
    /// Returns:
    ///   The content to return to the user. When set, the agent run will skipped and
    ///   the provided content will be appended to event history as agent response.
    /// Entry method to run an agent via text-based conversation.
    ///
    /// Args:
    ///   parent_context: InvocationContext, the invocation context of the parent agent.
    ///
    /// Returns:
    ///   AsyncGenerator of Event: the events generated by the agent.
    pub fn runAsync(self: *BaseAgent, parent_context: *InvocationContext) !std.ArrayList(Event) {
        var events = std.ArrayList(Event).init(std.heap.page_allocator);

        const ctx = self.createInvocationContext(parent_context);

        if (self.handleBeforeAgentCallback(ctx)) |event| {
            try events.append(event);
        }
        if (ctx.end_invocation) {
            return events;
        }

        // var impl_events = try self.runAsyncImpl(ctx);
        const impl_events = try self.runAsyncImpl(ctx);
        for (impl_events.items) |event| {
            try events.append(event);
        }

        if (ctx.end_invocation) {
            return events;
        }

        if (self.handleAfterAgentCallback(ctx)) |event| {
            try events.append(event);
        }

        return events;
    }

    /// Entry method to run an agent via video/audio-based conversation.
    ///
    /// Args:
    ///   parent_context: InvocationContext, the invocation context of the parent agent.
    ///
    /// Returns:
    ///   AsyncGenerator of Event: the events generated by the agent.
    pub fn runLive(self: *BaseAgent, parent_context: *InvocationContext) !std.ArrayList(Event) {
        var events = std.ArrayList(Event).init(std.heap.page_allocator);

        const ctx = self.createInvocationContext(parent_context);
        // TODO(hangfei): support before/after_agent_callback

        // var impl_events = try self.runLiveImpl(ctx);
        const impl_events = try self.runLiveImpl(ctx);
        for (impl_events.items) |event| {
            try events.append(event);
        }

        return events;
    }

    /// Core logic to run this agent via text-based conversation.
    ///
    /// Args:
    ///   ctx: InvocationContext, the invocation context for this agent.
    ///
    /// Returns:
    ///   AsyncGenerator of Event: the events generated by the agent.
    pub fn runAsyncImpl(self: *BaseAgent, ctx: *InvocationContext) !std.ArrayList(Event) {
        _ = self;
        _ = ctx;
        @panic("runAsyncImpl not implemented for this agent type");
    }

    /// Core logic to run this agent via video/audio-based conversation.
    ///
    /// Args:
    ///   ctx: InvocationContext, the invocation context for this agent.
    ///
    /// Returns:
    ///   AsyncGenerator of Event: the events generated by the agent.
    pub fn runLiveImpl(self: *BaseAgent, ctx: *InvocationContext) !std.ArrayList(Event) {
        _ = self;
        _ = ctx;
        @panic("runLiveImpl not implemented for this agent type");
    }

    /// Gets the root agent of this agent.
    pub fn getRootAgent(self: *BaseAgent) *BaseAgent {
        var root_agent = self;
        while (root_agent.parent_agent != null) {
            root_agent = root_agent.parent_agent.?;
        }
        return root_agent;
    }

    /// Finds the agent with the given name in this agent and its descendants.
    ///
    /// Args:
    ///   name: The name of the agent to find.
    ///
    /// Returns:
    ///   The agent with the matching name, or null if no such agent is found.
    pub fn findAgent(self: *BaseAgent, name: []const u8) ?*BaseAgent {
        if (std.mem.eql(u8, self.name, name)) {
            return self;
        }
        return self.findSubAgent(name);
    }

    /// Finds the agent with the given name in this agent's descendants.
    ///
    /// Args:
    ///   name: The name of the agent to find.
    ///
    /// Returns:
    ///   The agent with the matching name, or null if no such agent is found.
    pub fn findSubAgent(self: *BaseAgent, name: []const u8) ?*BaseAgent {
        for (self.sub_agents.items) |sub_agent| {
            if (sub_agent.findAgent(name)) |result| {
                return result;
            }
        }
        return null;
    }

    /// Creates a new invocation context for this agent.
    fn createInvocationContext(self: *BaseAgent, parent_context: *InvocationContext) *InvocationContext {
        var invocation_context = parent_context.clone();
        invocation_context.agent = self;

        if (parent_context.branch.len > 0) {
            var buffer = std.ArrayList(u8).init(std.heap.page_allocator);
            buffer.writer().print("{s}.{s}", .{ parent_context.branch, self.name }) catch unreachable;
            invocation_context.branch = buffer.items;
        }

        return invocation_context;
    }

    /// Runs the before_agent_callback if it exists.
    ///
    /// Returns:
    ///   Optional Event: an event if callback provides content or changed state.
    fn handleBeforeAgentCallback(self: *BaseAgent, ctx: *InvocationContext) ?Event {
        if (self.before_agent_callback == null) {
            return null;
        }

        var callback_context = CallbackContext.init(ctx);
        const before_agent_callback_content = self.before_agent_callback.?(&callback_context);

        if (before_agent_callback_content != null) {
            ctx.end_invocation = true;
            return Event{
                .invocation_id = ctx.invocation_id,
                .author = self.name,
                .branch = ctx.branch,
                .content = before_agent_callback_content,
                .actions = callback_context.event_actions,
            };
        }

        if (callback_context.state.hasDelta()) {
            return Event{
                .invocation_id = ctx.invocation_id,
                .author = self.name,
                .branch = ctx.branch,
                .actions = callback_context.event_actions,
            };
        }

        return null;
    }

    /// Runs the after_agent_callback if it exists.
    ///
    /// Returns:
    ///   Optional Event: an event if callback provides content or changed state.
    fn handleAfterAgentCallback(self: *BaseAgent, ctx: *InvocationContext) ?Event {
        if (self.after_agent_callback == null) {
            return null;
        }

        var callback_context = CallbackContext.init(ctx);
        const after_agent_callback_content = self.after_agent_callback.?(&callback_context);

        if (after_agent_callback_content != null or callback_context.state.hasDelta()) {
            return Event{
                .invocation_id = ctx.invocation_id,
                .author = self.name,
                .branch = ctx.branch,
                .content = after_agent_callback_content,
                .actions = callback_context.event_actions,
            };
        }

        return null;
    }

    /// Validates the agent name.
    pub fn validateName(name: []const u8) !void {
        // Check if name is a valid identifier
        if (name.len == 0) {
            return error.InvalidName;
        }

        if (!std.ascii.isAlpha(name[0]) and name[0] != '_') {
            return error.InvalidName;
        }

        for (name[1..]) |c| {
            if (!std.ascii.isAlphanumeric(c) and c != '_') {
                return error.InvalidName;
            }
        }

        // Check if name is not "user"
        if (std.mem.eql(u8, name, "user")) {
            return error.ReservedName;
        }
    }

    /// Sets the parent agent for all sub-agents.
    pub fn setParentAgentForSubAgents(self: *BaseAgent) !void {
        for (self.sub_agents.items) |sub_agent| {
            if (sub_agent.parent_agent != null) {
                return error.AgentAlreadyHasParent;
            }
            sub_agent.parent_agent = self;
        }
    }

    /// Initializes a new BaseAgent.
    pub fn init(name: []const u8, description: []const u8) !*BaseAgent {
        try validateName(name);

        const agent = try std.heap.page_allocator.create(BaseAgent);
        agent.* = BaseAgent{
            .name = name,
            .description = description,
            .parent_agent = null,
            .sub_agents = std.ArrayList(*BaseAgent).init(std.heap.page_allocator),
            .before_agent_callback = null,
            .after_agent_callback = null,
        };

        return agent;
    }
};
